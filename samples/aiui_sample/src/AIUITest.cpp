#include "AIUITest.h"#include <string.h>#include <stdlib.h>#include "RobotIntentFactory.h"#include "RobotIntent.h"using namespace VA;void WriteAudioThread::initAudio(){		int size;		int rc;		snd_pcm_hw_params_t *params;		unsigned int val;		int dir;				/* Open PCM device for recording (capture). */		rc = snd_pcm_open(&handle, "default", SND_PCM_STREAM_CAPTURE, 0);		if (rc < 0) {			fprintf(stderr,			"unable to open pcm device: %s\n",			snd_strerror(rc));			exit(1);		}		/* Allocate a hardware parameters object. */		snd_pcm_hw_params_alloca(&params);		/* Fill it in with default values. */		snd_pcm_hw_params_any(handle, params);		/* Set the desired hardware parameters. */		/* Interleaved mode */		snd_pcm_hw_params_set_access(handle, params,		SND_PCM_ACCESS_RW_INTERLEAVED);		/* Signed 16-bit little-endian format */		snd_pcm_hw_params_set_format(handle, params,		SND_PCM_FORMAT_S16_LE);		/* Two channels (stereo) */		snd_pcm_hw_params_set_channels(handle, params, 1);		/* 44100 bits/second sampling rate (CD quality) */		val = 16000;		snd_pcm_hw_params_set_rate_near(handle, params,		&val, &dir);		/* Set period size to 32 frames. */		frames = 32;		snd_pcm_hw_params_set_period_size_near(handle,		params, &frames, &dir);		/* Write the parameters to the driver */		rc = snd_pcm_hw_params(handle, params);		if (rc < 0) {			fprintf(stderr,			"unable to set hw parameters: %s\n",			snd_strerror(rc));			exit(1);		}		/* Use a buffer large enough to hold one period */		snd_pcm_hw_params_get_period_size(params,		&frames, &dir);		size = frames * 2; /* 2 bytes/sample, 2 channels */		audioBuffer = (char *) malloc(size);}int WriteAudioThread::readAudio(){	int rc;	rc = snd_pcm_readi(handle, audioBuffer, frames);	if (rc == -EPIPE) {		/* EPIPE means overrun */		fprintf(stderr, "overrun occurred\n");		snd_pcm_prepare(handle);	} else if (rc < 0) {		fprintf(stderr,	"error from read: %s\n");	} else if (rc != (int)frames) {		fprintf(stderr, "short read, read frames\n");	}	//rc = write(1, audioBuffer, frames * 2);	//if (rc != size)	//	fprintf(stderr, "short write: wrote %d bytes\n", rc);	return 0;}bool WriteAudioThread::threadLoop(){		readAudio();	Buffer* buffer = Buffer::alloc(frames * 2);	memcpy(buffer->data(), audioBuffer, frames * 2);	IAIUIMessage * writeMsg = IAIUIMessage::create(AIUIConstant::CMD_WRITE,			0, 0,  "data_type=audio,sample_rate=16000", buffer);		if (NULL != mAgent)	{		mAgent->sendMessage(writeMsg);	}			writeMsg->destroy();	return mRun;}void* WriteAudioThread::thread_proc(void * paramptr){	WriteAudioThread * self = (WriteAudioThread *)paramptr;	while (1) {		if (! self->threadLoop())			break;	}	return NULL;}WriteAudioThread::WriteAudioThread(IAIUIAgent* agent, const string& audioPath, bool repeat):mAgent(agent), mAudioPath(audioPath), mRepeat(repeat), mRun(true), mFileHelper(NULL),thread_created(false){	mFileHelper = new FileUtil::DataFileHelper("");	mFileHelper->openReadFile(mAudioPath, false);	initAudio();}WriteAudioThread::~WriteAudioThread(){	}void WriteAudioThread::stopRun(){    if (thread_created) {        mRun = false;        void * retarg;        pthread_join(thread_id, &retarg);        thread_created = false;    }}bool WriteAudioThread::run(){    if (thread_created == false) {        int rc = pthread_create(&thread_id, NULL, thread_proc, this);        if (rc != 0) {            exit(-1);        }        thread_created = true;        return true;    }    return false;}void TestListener::onEvent(const IAIUIEvent& event) const{	switch (event.getEventType()) {	case AIUIConstant::EVENT_STATE:		{			switch (event.getArg1()) {			case AIUIConstant::STATE_IDLE:				{					cout << "EVENT_STATE:" << "IDLE" << endl;				} break;			case AIUIConstant::STATE_READY:				{					cout << "EVENT_STATE:" << "READY" << endl;				} break;			case AIUIConstant::STATE_WORKING:				{					cout << "EVENT_STATE:" << "WORKING" << endl;				} break;			}		} break;	case AIUIConstant::EVENT_WAKEUP:		{			cout << "EVENT_WAKEUP:" << event.getInfo() << endl;		} break;	case AIUIConstant::EVENT_SLEEP:		{			cout << "EVENT_SLEEP:arg1=" << event.getArg1() << endl;		} break;	case AIUIConstant::EVENT_VAD:		{			switch (event.getArg1()) {			case AIUIConstant::VAD_BOS:				{					cout << "EVENT_VAD:" << "BOS" << endl;				} break;			case AIUIConstant::VAD_EOS:				{					cout << "EVENT_VAD:" << "EOS" << endl;				} break;			case AIUIConstant::VAD_VOL:				{								} break;			}		} break;	case AIUIConstant::EVENT_RESULT:		{			Json::Value bizParamJson;			Json::Reader reader;						if (!reader.parse(event.getInfo(), bizParamJson, false)) {				cout << "parse error!" << endl << event.getInfo() << endl;				break;			}			Json::Value data = (bizParamJson["data"])[0];			Json::Value params = data["params"];			Json::Value content = (data["content"])[0];			string sub = params["sub"].asString();			cout << "EVENT_RESULT:" << sub << endl;			if (sub == "nlp")			{				Json::Value empty;				Json::Value contentId = content.get("cnt_id", empty);				if (contentId.empty())				{					cout << "Content Id is empty" << endl;					break;				}				string cnt_id = contentId.asString();				Buffer* buffer = event.getData()->getBinary(cnt_id.c_str());				string resultStr;				if (NULL != buffer)				{					resultStr = string((char*)buffer->data());					cout << resultStr << endl;					Json::Value resultJson, intentJson;					if(!reader.parse(resultStr, resultJson, false)){						cout << "NLP intent json parse error" << endl;						cout << resultStr << endl;						break;									}					intentJson =  resultJson["intent"];					RobotIntent *mRobotIntent = RobotIntentFactory::createRobotIntent(mRobot, intentJson);					if(mRobotIntent  == NULL)						break;					mRobotIntent->execAction();				}				else				{					cout << "buffer is NULL" << endl;				}			}		}		break;	case AIUIConstant::EVENT_ERROR:		{			cout << "EVENT_ERROR:" << event.getArg1() << endl;		} break;	}}AIUITester::AIUITester() : agent(NULL), writeThread(NULL){}AIUITester::~AIUITester(){	if (agent) {		agent->destroy();		agent = NULL;	}}void AIUITester::createAgent(){	string appid = "5a5b1d9a";	Json::Value paramJson;	Json::Value appidJson;	appidJson["appid"] = appid;		string fileParam = FileUtil::readFileAsString(CFG_FILE_PATH);	Json::Reader reader;	if(reader.parse(fileParam, paramJson, false))	{		paramJson["login"] = appidJson;		Json::FastWriter writer;		string paramStr = writer.write(paramJson);		agent = IAIUIAgent::createAgent(paramStr.c_str(), &listener);	}	else	{		cout << "aiui.cfg has something wrong!" << endl;	}}void AIUITester::wakeup(){	if (NULL != agent)	{		IAIUIMessage * wakeupMsg = IAIUIMessage::create(AIUIConstant::CMD_WAKEUP);		agent->sendMessage(wakeupMsg);		wakeupMsg->destroy();	}}void AIUITester::start(){	if (NULL != agent)	{		IAIUIMessage * startMsg = IAIUIMessage::create (AIUIConstant::CMD_START);		agent->sendMessage(startMsg);		startMsg->destroy();	}}void AIUITester::stop(){	if (NULL != agent)	{		IAIUIMessage *stopMsg = IAIUIMessage::create (AIUIConstant::CMD_STOP);		agent->sendMessage(stopMsg);		stopMsg->destroy();	}}void AIUITester::write(bool repeat){	if (agent == NULL)	{		cout << "write anget == null" << endl;		return;	}	if (writeThread == NULL) {		writeThread = new WriteAudioThread(agent, TEST_AUDIO_PATH,  repeat);		writeThread->run();	}	}void AIUITester::stopWriteThread(){	if (writeThread) {		writeThread->stopRun();		delete writeThread;		writeThread = NULL;	}}void AIUITester::reset(){	if (NULL != agent)	{		IAIUIMessage * resetMsg = IAIUIMessage::create(AIUIConstant::CMD_RESET);		agent->sendMessage(resetMsg);		resetMsg->destroy();	}}void AIUITester::writeText(){	if (NULL != agent)	{		string text = "刘德华的歌。";		cout << "input the text" << endl;		cin >> text;		// textData内存会在Message在内部处理完后自动release掉		Buffer* textData = Buffer::alloc(text.length());		text.copy((char*) textData->data(), text.length());		IAIUIMessage * writeMsg = IAIUIMessage::create(AIUIConstant::CMD_WRITE,			0,0, "data_type=text", textData);			agent->sendMessage(writeMsg);		writeMsg->destroy();			}}void AIUITester::destory(){	stopWriteThread();	if (NULL != agent)	{		agent->destroy();		agent = NULL;	}}void AIUITester::readCmd(){	cout << "input cmd:" << endl;	string cmd;	while (true)	{		cin >> cmd;		if (cmd == "c")		{			cout << "createAgent" << endl;			createAgent();		} else if (cmd == "w") {			cout << "wakeup" << endl;			wakeup();		} else if (cmd == "s") {			cout << "start" << endl;			start();		} else if (cmd == "st") {			cout << "stop" << endl;			stop();		} else if (cmd == "d") {			cout << "destroy" << endl;			destory();		} else if (cmd == "r") {			cout << "reset" << endl;			reset();		} else if (cmd == "e") {			cout << "exit" << endl;			break;		} else if (cmd == "wr") {			cout << "write" << endl;			write(false);		} else if (cmd == "wrr") {			cout << "write repeatly" << endl;			write(true);		} else if (cmd == "swrt") {			cout << "stopWriteThread" << endl;			stopWriteThread();		} else if (cmd == "wrt") {			cout << "writeText" << endl;			writeText();		} else if (cmd == "q") {			destory();			break;		} else {			cout << "invalid cmd, input again." << endl;		}	}}void AIUITester::createRobot(){	string ip = "10.10.56.214";	mRobot = new RobotAgent(ip, 23234);	listener.mRobot = mRobot;	cout << "create robot finish" << endl;	mRobot->initRobot();		// 设置为手动模式 设置速度}void AIUITester::test(){	AIUISetting::setAIUIDir(TEST_ROOT_DIR);	AIUISetting::initLogger(LOG_DIR);	createAgent();	sleep(1);	wakeup();	sleep(1);	start();	sleep(1);	createRobot();	sleep(1);	write(false);	cout << "init finish" << endl;	//while(true){	//	writeText();		//}	readCmd();}